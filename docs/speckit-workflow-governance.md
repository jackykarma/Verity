# Speckit 工作流实施与变更治理指南

本文档用于把你定制的 Speckit 工作流**落地成可执行的团队协作规范**：从需求 `spec` → UX/UI → `plan` → `tasks` → `implement`，以及当需求/交互/视觉/方案发生变更时，如何**可审计、可追溯、可控地级联更新**下游产物。

> 适用范围：本仓库的 Spec-Kit 工作流（命令位于 `.cursor/commands/speckit.*.md`，模板位于 `.specify/templates/`）。
>
> 依赖文档：
> - `docs/custom-spec-dev-in-one-epic-branch.md`（一个 EPIC 一个开发分支的运行方式）
> - `.specify/memory/constitution.md`（Plan 阶段演进式设计约束：基于现有代码、差距分析、最小改动等）

---

## 0. 目标与原则（先定“游戏规则”）

### 0.1 目标

- **单一事实源**：每类信息只在一个权威位置维护，其他文档只引用与追溯，避免口径漂移。
- **可落地**：文档粒度与风险匹配，小 Feature 不被重装甲模板拖垮，大 Feature 不因缺设计导致返工。
- **可治理的变更**：任何变更都能回答：改了什么、影响谁、要更新哪些产物、回滚怎么做。

### 0.2 核心原则（务必统一）

- **事实源分层（SoT）**：需求事实源是 `spec.md`；体验呈现事实源是 `ux-design.md`；技术决策事实源是 `plan.md`；执行事实源是 `tasks.md`。
- **变更先影响分析、再增量更新**：不追求“一键自动改完所有东西”，而是追求“自动生成影响与更新清单 + 人工可审计地执行更新”。
- **演进式设计（非推翻式）**：Plan 必须基于现有代码与约束输出，遵循 `.specify/memory/constitution.md`。

---

## 1. 术语与产物分层（Source of Truth）

### 1.1 概念层级

- **EPIC**：大需求容器、统一边界、跨 Feature 验收与预算（`epic.md`）。
- **Feature**：可交付单元，拥有完整 FR/NFR/AC（`spec.md`）。
- **UX Design（EPIC 级）**：导航、流程、交互规则、视觉与动效清单、设计稿索引（`ux-design.md` + `design/` 或 Figma 链接）。
- **Plan**：工程级蓝图（架构边界/契约/失败模式/NFR 预算/风险与回滚 + Story 拆分）（`plan.md`）。
- **Story（ST-xxx）**：Feature 最小可开发单元（在 `plan.md` 的 Story Breakdown）。
- **Task（Txxx）**：Story 的可执行落地步骤（`tasks.md`）。
- **Implement**：按 `tasks.md` 落码与验证；不允许偷改 spec/plan 的权威口径。

### 1.2 事实源（SoT）表

| 信息类型 | 权威文档（SoT） | 其他文档如何使用 |
|---|---|---|
| 范围（In/Out）、FR/NFR、验收 AC、边界/异常 | `spec.md` | UX/Plan/Tasks 只能**引用/映射**，不得改写口径 |
| 导航/交互规则/状态、视觉规范、动效清单、设计稿索引 | `ux-design.md`（EPIC 级） | Plan 引用并在实现策略里落地（性能/功耗/降级等） |
| 架构边界、契约、错误语义、失败策略、NFR 预算与测量方式、风险/回滚、Story 拆分 | `plan.md` | Tasks 只能拆解执行；Implement 不得越权改写 |
| 执行步骤、依赖与并行、验证步骤（可执行） | `tasks.md` | Implement 的唯一执行清单 |

> 经验法则：**凡是“能被测试验收”的东西，最终都要落到 `spec.md`（FR/NFR/AC/边界）或 `plan.md`（测量方法/预算/降级/回滚）**；否则容易在实现期争论口径。

---

## 2. 角色分工（谁改什么）

推荐职责（按你们团队实际可微调）：

- **产品（PM）**：PRD、范围与验收目标；参与 Feature spec 澄清并确认 AC。
- **设计（UX/UI）**：EPIC 级 `ux-design.md`、设计稿索引、动效清单与说明；对交互/视觉变更提供“变更说明 + 影响面”。
- **SE/TL（方案负责人）**：`plan.md`、`tasks.md` 的权威维护者；对变更做影响分析并驱动下游更新。
- **开发（Dev）**：严格按 `tasks.md` 实现与验证；发现设计缺口时发起变更请求（CR），不得自行修改 spec/plan 决策口径。

---

## 3. 主线流程（从 0 到 1 跑起来）

> 具体命令与目录规范建议先通读：`docs/custom-spec-dev-in-one-epic-branch.md`。

### 3.1 主线顺序（默认）

1. **PRD 澄清/整理**（会议纪要可选，但必须沉淀到 Epic/Feature 的事实源字段）
2. **EPIC Specify**：产出 `epic.md`（边界、拆分 Feature 列表、通用能力、EPIC 级预算/验收）
3. **Feature Specify（逐个）**：产出每个 Feature 的 `spec.md`（FR/NFR/AC/边界/依赖/实体）
4. **EPIC UX/UI（整体）**：产出 `ux-design.md`（信息架构、交互规则、视觉/动效、设计稿索引）
5. **Feature Clarify（逐个，可选但建议）**：补齐不可缺的澄清点
6. **Feature Plan（逐个）**：产出 `plan.md`（工程决策、风险与 NFR 预算、Story 拆分）
7. **Feature Tasks（逐个）**：产出 `tasks.md`（绑定 ST-xxx，带路径、步骤、验证）
8. **Implement**：开发者在 story 分支按 `tasks.md` 执行；完成后 PR 回 EPIC 分支集成
9. **EPIC Sync / EPIC Full Design**：保持 EPIC 总览与全局一致性

### 3.2 推荐关卡（Definition of Ready / Done）

- **进入 Plan 前（Feature DoR）**：
  - `spec.md` 的范围/FR/NFR/AC/边界齐全且可测试
  - `ux-design.md` 中存在该 Feature 的页面/流程索引与交互规则映射（若 EPIC 有 ux-design）
  - 关键依赖与失败模式已列出（spec/ux 中至少要有）

- **进入 Implement 前（Design Freeze）**：
  - `plan.md` 已通过评审，关键决策已固化（Plan Version 记录）
  - `tasks.md` 已生成且可执行（每个 Task 有验证方式）
  - `epic.md` Registry 已同步（便于端到端追踪）

---

## 4. Plan 细化粒度：分级（避免“过于理想化/过度文档化”）

你当前的 `plan-template.md` 属于“重装甲模板”，建议在执行时按风险分级启用，避免小需求被压垮。

### 4.1 Plan 分级定义

#### Plan-Lite（小改动/低风险）

适用：页面小改、已有模块加字段、轻量业务逻辑、无新持久化/无新外部契约/无复杂并发与动效。

最低必须输出：
- **A2**：Feature 全景架构（边界 + 外部依赖 + 失败策略）
- **A3.1**：组件清单与职责（哪几个组件、谁负责什么）
- **Story Breakdown**：ST-xxx 列表与 FR/NFR 覆盖矩阵
- **NFR 预算最小集**：至少写清“是否新增/变化了性能/功耗/内存风险”及测量方式（可简化）

#### Plan-Standard（默认）

适用：大多数 Feature。

建议输出（除 Lite 外）：
- **A3.0/A3.2/A3.3**：至少 1 张关键端到端时序图（同图含异常）+ 关键类图
- **A4 风险与消解策略**：绑定到 Story/Task
- **Plan-B 的关键规约落点**：线程/错误处理/可观测性字段最小集

#### Plan-Deep（高风险/高不确定性）

触发条件（任一满足就建议 Deep）：
- 新增/变更 **跨模块或外部契约**（API/SDK/数据协议）
- 新增 **持久化/迁移**（Room/文件/KV 结构版本）
- 存在 **复杂动效/多状态机/强性能预算**（动画、列表高频刷新、重绘、低端机适配）
- 存在 **并发/取消语义难点**（竞态、重入、后台任务一致性）
- 需要 **灰度/回滚** 或对历史包袱兼容要求高

Deep 额外要求：
- **A3.4 组件详细设计**（至少对关键组件补齐异常矩阵）
- **Story Detailed Design（L2）**（只对高风险 Story 补齐，不必全量）

> 落地建议：Plan 并不是“写得越多越好”，而是“**把会导致返工与线上风险的决策写清楚**”。其余细节留给实现期在约束内完成。

---

## 5. 变更治理：统一入口 CR（Change Request）

### 5.1 为什么需要 CR

现实项目里变更不可避免。若允许“直接改 spec/ux/plan/tasks”，会造成：
- 变更缺少审计（不知道为什么改、改了多少、影响了谁）
- 下游产物遗漏更新（tasks/代码继续按旧口径做）
- 争论口径（需求/交互/验收到底以哪个文档为准）

因此建议：**任何变更都先创建 CR，再按清单增量更新产物**。

> 本仓库已提供可直接复制的 CR 模板：`.specify/templates/change-request-template.md`。

### 5.2 CR 最小模板（建议放在 PR 描述或单独文档）

```text
CR-ID：CR-YYYYMMDD-xxx
类型：需求 / 交互 / 视觉&动效 / 技术方案 / 混合
发起人：xxx
日期：YYYY-MM-DD

1) 变更内容（What changed）
- 新增：…
- 修改：…
- 删除：…

2) 变更原因与证据（Why）
- 用户反馈/数据/复现/约束变化：…

3) 影响分析（Impact）
- 影响的 EPIC/Feature：EPIC-xxx；FEAT-xxx…
- 影响的 spec（FR/NFR/AC/边界）：FR-… / NFR-… / AC-…
- 影响的 UX（页面/流程/动效）：UI-… / Flow-… / Motion-…
- 影响的 Plan（决策点/契约/风险/预算）：A1/A2/A3/A4/Plan-B…
- 影响的 Story/Task：ST-… / T…
- 是否需要回滚：是/否（理由）

4) 更新清单（Update checklist）
- [ ] 更新 `ux-design.md`（章节：…）
- [ ] 更新 `spec.md`（章节：…；Version：vX→vY）
- [ ] 更新 `plan.md`（章节：…；Version：vX→vY）
- [ ] 重新生成/更新 `tasks.md`（Version：vX→vY）
- [ ] 同步 `epic.md` Registry（/speckit.epicsync）
```

> 关键点：CR 的价值在“影响分析 + 更新清单”，这比“自动改一切”更可控、更容易评审。

---

## 6. 变更类型与下游传播规则（判定表）

### 6.1 需求变更（PRD/范围/验收变化）

**判定**：会改变用户可验证结果、范围边界、验收口径（AC）、或 NFR 预算。

**必更新**：
- `spec.md`（FR/NFR/AC/边界与异常）
- `plan.md`（差距分析、契约/失败策略、预算与降级、风险与回滚）
- `tasks.md`（Story/Task 追溯与验证方式必须跟上）

### 6.2 交互变更（流程/状态/反馈规则变化）

交互变更经常“看似设计变了”，本质是验收变了。建议按以下规则判断是否进入 `spec.md`：

- **必须进入 `spec.md` 的交互变更**（属于需求/验收变更）：
  - 改变流程步骤、确认逻辑、权限/前置条件
  - 改变错误处理方式（例如从“允许继续”变成“必须阻断”）
  - 改变状态定义导致可测试行为变化（loading/空态/失败态的定义或触发条件）

- **可以只留在 `ux-design.md` 的交互变更**（不改变验收口径）：
  - 不影响行为的微交互（提示文案微调、轻微过渡）
  - 不影响核心流程的布局与引导优化（但仍应评估是否引入性能风险）

**传播**：
- 先更新 `ux-design.md`
- 若触发“必须进入 spec”的条件：更新 `spec.md` → `plan.md` → `tasks.md`
- 若不触发：至少更新 `plan.md`（实现策略/风险/约束）与 `tasks.md`（任务步骤/验证）

### 6.3 视觉/动效变更

视觉动效与需求范围的关系取决于它是否引入“可验收约束”与“系统性风险”：

- **仅审美/一致性**：更新 `ux-design.md` + `tasks.md` + code
- **新增硬性动效约束**（必须出现的动效、时长、缓动规则）或显著复杂度上升：
  - 需要在 `spec.md` 补充 AC（或 NFR-PERF/NFR-POWER 的约束）
  - 需要在 `plan.md` 写清实现策略、性能预算、降级/回滚（低端机/省电模式/动态开关等）

### 6.4 技术方案变更（Plan 决策推翻）

**判定**：架构边界、契约、错误语义、缓存/一致性、并发模型、NFR 预算/测量方式发生变化。

**必更新**：
- `plan.md`（提升 Plan Version、写变更记录、明确影响范围与回滚）
- `tasks.md`（重新拆解/重排依赖/补验证）
- 必要时 `spec.md`（若决策变化导致验收口径/NFR 变化）

**硬规则**：Implement 阶段不得“偷偷修正 Plan 决策”。发现方案不成立必须发起 CR，回到 Plan 增量更新。

---

## 7. 你的两个关键问题的“可执行答案”

### 7.1 PRD 需求与交互视觉引入的需求要放一起吗？

建议：**逻辑上放一起、物理上分层存储**。

- **所有可验收的需求口径**统一沉到 `spec.md`（FR/NFR/AC/边界）——这保证验收只有一个事实源。
- **交互/视觉/动效的呈现细节**留在 `ux-design.md`，并通过“映射 FR/流程”建立追溯。
- 若交互/动效是跨 Feature 的共性能力，升级为 **Capability Feature**（在 `epic.md` 的“通用能力”登记），避免每个业务 Feature 重复定义口径与资产规范。

### 7.2 技术方案设计要细化到什么粒度最合适？与代码实现如何划分？

**Plan 的最合适粒度**是：把“会导致返工或线上风险”的内容写到**决策/契约/失败模式/预算**级别，而不是写到“每行代码”级别。

- `plan.md` 应该写清：
  - 边界与依赖方向（A2/A3）
  - 关键接口/数据契约（签名级别 + 错误语义）
  - 失败模式与对策（重试/退避/降级/提示/告警）
  - 并发与取消语义（避免竞态/重入/半写入）
  - 性能/功耗/内存预算与测量方式（阈值 + 方法）
  - 风险与回滚策略（绑定到 Story/Task）

- 实现（Implement）负责：
  - 具体类/文件落点的最终细节、Compose 组件实现与 UI 细节
  - 具体 API 调用方式、日志字段落地、测试与基准脚本实现
  - 在 Plan 约束内的工程化细节优化

---

## 8. 常见反模式（要避免）

- **把“设计文档”当“自动生成物”**：文档必须服务决策与协作，不要为了“流程完整”而堆字。
- **不经 CR 直接改下游**：尤其是实现期改 plan/spec，最容易造成“需求与实现脱节”。
- **Plan 一刀切写到最细**：小 Feature 采用 Plan-Lite/Standard；只有高风险才 Deep。
- **UX 变更不做影响评估**：动效/视觉变更可能引入性能/功耗风险，必须显式预算与降级策略。

---

## 9. 建议的最小落地动作（你现在就可以执行）

- 把“CR 模板”作为团队约定的唯一变更入口（写进 PR 模板或约定到评审流程里）。
- 在每个 Feature 的 Plan 评审前，先判定 Plan 分级（Lite/Standard/Deep），避免无谓文档负担。
- 交互/视觉变更时，先更新 `ux-design.md`，再按判定表决定是否同步到 `spec.md`（FR/NFR/AC），最后再更新 `plan/tasks`。

