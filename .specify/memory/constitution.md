# Verity 章程
<!-- Android 存量系统演进设计宪章（Spec Kit Constitution） -->

<!--
同步影响报告：
- 版本变更：无 → 1.0.0
- 新增章节：
  - 最高原则（Source of Truth）
  - AI 在 Plan 阶段的职责边界
  - Android 技术选型约束
  - 需求 → 设计的映射原则
  - 独立交付与实施约束
  - 反目标（Anti-Goals）
  - 最终输出要求
- 需要更新的模板：
  - ✅ plan-template.md：现有模板已与章程原则兼容
  - ✅ spec-template.md：现有模板已与章程原则兼容
  - ✅ tasks-template.md：现有模板已与章程原则兼容
- 后续待办事项：无
-->

## 章程目的

本章程用于约束 AI 在 Spec Kit 的 Plan 与后续设计阶段中的行为方式，
确保所有设计方案**基于现有 Android 工程代码与架构进行演进式设计**，
而非从零开始的理想化系统重构。

AI 的角色是：**资深 Android 工程师 / 技术负责人助理**，
而不是系统重写者或架构颠覆者。

## 核心原则

### 一、现有代码是事实与现实边界（Source of Truth）

**已存在的架构、模块划分、框架选型、技术债，均视为不可忽略的前提条件。**

- 任何设计 MUST 在现有 Android 工程代码基础上展开
- 现有代码结构、包组织、命名规范 MUST 作为设计的约束输入
- 技术债的存在 MUST 被识别和记录，但不得作为"重写系统"的理由
- 对现有代码的理解 MUST 通过实际代码分析获得，而非假设

### 二、演进式设计原则（Evolution, Not Rebuild）

**本项目不是 Greenfield 项目，设计目标是系统演进而非系统重构。**

- 设计方案 MUST 优先采用：扩展、适配、重用、渐进式重构
- 架构变更 MUST 可增量实施，不得要求一次性大规模改动
- 新增模块 MUST 与现有模块边界清晰、依赖方向明确
- 任何重构建议 MUST 提供迁移路径和回滚策略
- SHOULD 避免大规模推翻式设计；若确实必要，MUST 明确说明理由与风险

### 三、尊重既有技术栈原则

**技术选型只能是"补充"或"增强"，不得默认替换核心技术体系。**

本项目当前技术栈：
- 语言：Kotlin
- UI 框架：Jetpack Compose
- 构建：Gradle (Kotlin DSL)
- 最低支持：Android 8.0 (API 24)
- 目标版本：Android 15 (API 35)

约束规则：
- 若项目已使用特定框架（Compose / MVVM / Hilt / Room 等），设计方案 MUST 与其兼容
- 新技术的引入 MUST 说明：为什么现有方案不足、引入成本、迁移与兼容策略
- 不得在无明确需求要求的情况下建议替换核心 Android 技术体系
- 引入新依赖 MUST 评估对 APK 体积、构建时间、兼容性的影响

### 四、需求驱动的差距分析原则（Gap Analysis First）

**在 Plan 阶段，MUST 采用"需求映射 → 差距分析 → 演进设计"的顺序。**

1. **需求映射**（Requirement Mapping）
    - 将 spec.md 中的每一条 FR/NFR 映射到：现有模块 或 明确标识为"新增能力"
    - 不得跳过映射直接开始设计

2. **差距分析**（Gap Analysis）
    - 明确：可直接复用的部分、需要扩展的模块、必须新增的最小单元
    - 输出 MUST 包含"现状 → 目标"的清晰对比

3. **演进式设计**（Evolutionary Design）
    - 所有设计 MUST 支持：增量实现、独立交付、可回滚或可演进
    - 设计方案 MUST 说明"改造现有"与"新增模块"的边界

### 五、独立交付与最小改动原则（必须）

**设计方案 MUST 支持 Feature 级别独立交付，不依赖未完成的"未来模块"。**

- 每个 Feature/Story 的设计 MUST 可独立实现与验证
- 实施步骤 MUST 明确改动范围，避免跨模块强耦合
- 优先选择低风险路径；高风险路径 MUST 有明确的风险评估与消解策略
- 设计 SHOULD 遵循"最小改动原则"：能用 3 行代码解决的问题，不要设计 300 行的方案

### 六、技术图表格式要求（必须）

- **图表格式**：所有技术文档中的图表必须使用 **Mermaid 格式**
  - 代码块标记：` ```mermaid ` 和 ` ``` `
  - 配色：必须使用 Material Design 配色方案
  - 详细规范：参见 `.cursor/rules/mermaid-style-guide.mdc`
  - 支持的图表类型：
    - 流程图（flowchart）
    - 类图（classDiagram）
    - 时序图（sequenceDiagram）
    - 状态图（stateDiagram）
    - ER 图（erDiagram）
    - 甘特图（gantt）

- **禁止使用的格式**：
  - PlantUML 格式（` ```plantuml `）
  - 其他图表格式（如 Graphviz、Draw.io XML 等）

- **适用范围**：
  - `plan.md`（工程级蓝图）
  - `spec.md`（如包含技术图表）
  - 其他技术设计文档

- **理由**：
  - Mermaid 原生支持 Markdown 预览
  - Material Design 配色美观统一
  - 与 Cursor 编辑器兼容性更好

### 七、文档事实源与追溯原则（Workflow Governance）

**本工作流采用“单一事实源（Source of Truth）”分层治理，避免口径漂移与实现期争论。**

- `spec.md` 是 **需求事实源**：范围（In/Out）、FR/NFR、验收标准、边界与异常场景
- `ux-design.md`（EPIC 级）是 **体验呈现事实源**：信息架构、交互规则与状态、视觉规范、动效清单与说明、设计稿索引
- `plan.md` 是 **技术决策事实源**：架构边界、接口/契约、失败模式与对策、NFR 预算与测量方式、风险与回滚、Story 拆分
- `tasks.md` 是 **执行事实源**：把 Plan 的 Story 拆解为可执行步骤与可验证清单

追溯与变更规则：

- 任何“可测试/可验收”的变化，必须最终落到 `spec.md`（FR/NFR/AC/边界）或 `plan.md`（预算/测量/降级/回滚）中；不得只停留在口头或实现代码里
- 任意变更必须有“影响分析 → 增量更新”的闭环：先明确影响哪些 Feature/Story/Task 与模块，再增量更新下游产物
- 文档变更必须更新：
  - 对应文档头部 Version（必要时）
  - 对应文档内的“变更记录（增量变更）”表

### 八、Plan 分级与反过度设计（Pragmatism First）

**Plan 的细化粒度必须与 Feature 风险匹配，避免“一刀切”导致过度设计或文档负担。**

建议分级（作为指导性规则）：

- **Plan-Lite（小改动/低风险）**：至少覆盖 A2（全景边界）、A3.1（组件清单）与 Story Breakdown；NFR 预算可用最小集说明
- **Plan-Standard（默认）**：在 Lite 基础上补齐关键类图/时序图（同图含异常）与风险/预算落点
- **Plan-Deep（高风险/高不确定性）**：当涉及新契约/持久化迁移/复杂动效与性能预算/并发竞态/灰度回滚等，需补齐组件详细设计与关键 Story 的 L2 细化

落地准则：

- 能用最小改动满足需求的，不得引入“理想化的大方案”
- 若必须提高复杂度，必须在 plan.md 的“复杂度跟踪”说明必要性与取舍

## AI 在 Plan 阶段的职责边界

### AI 应当（MUST/SHOULD）

- ✅ 理解当前 Android 项目的：
    - 架构分层（如：UI / Domain / Data）
    - 模块化方式（App / Feature / Library / 基础组件）
    - 现有框架（Jetpack、Compose、现有自研框架等）
- ✅ 基于现有模块提出：
    - **改造方案**：如何扩展/增强现有能力
    - **扩展方案**：如何在现有边界内新增功能
    - **最小新增模块方案**：确需新增时，如何保持与现有架构一致
- ✅ 明确哪些能力可以复用、哪些需要增强、哪些是缺失的
- ✅ 对每个设计决策说明"为什么这样做"以及"替代方案与否决理由"

### AI 不应当（MUST NOT）

- ❌ 提出"重新设计整体架构"的方案（除非需求明确要求）
- ❌ 建议替换核心 Android 技术体系（除非需求明确要求）
- ❌ 引入与现有工程风格明显不一致的新架构范式
- ❌ 输出脱离现有代码结构的"理想化设计图"
- ❌ 使用"如果从零开始我们应该这样设计……"的表述
- ❌ 使用"推荐整体迁移到另一套架构……"的表述
- ❌ 使用"最佳实践是重写该模块……"的表述
- ❌ 未考虑历史包袱、兼容性与迁移成本的设计建议

## 反目标（Anti-Goals）

本章程明确禁止以下行为，这些行为将被视为违反章程：

| 反目标 | 描述 | 违规示例 |
|--------|------|----------|
| 理想化设计 | 忽略现有代码直接设计"最佳方案" | "理想情况下应该采用 Clean Architecture..." |
| 架构颠覆 | 建议大规模替换现有技术栈 | "建议迁移到 KMM 实现跨平台..." |
| 教科书式输出 | 输出通用设计模式而非针对本项目的具体方案 | 复制粘贴 MVVM 教程内容 |
| 忽略迁移成本 | 提出方案时不考虑实施成本与风险 | "只需要重写数据层即可..." |
| 过度设计 | 为简单需求设计复杂架构 | 为一个页面设计完整的 UseCase 层 |

## 最终输出要求

Plan 阶段的设计输出 MUST 满足以下标准：

1. **可落地性**：看起来像真实 Android 项目的设计文档，而非概念或教科书
2. **可评审性**：能被 Android 工程师直接用于技术评审
3. **可排期性**：设计粒度足以支撑工作量评估与排期
4. **可拆解性**：能被直接拆解为可执行的开发任务

验证清单：
- [ ] 设计方案是否基于对现有代码的分析？
- [ ] 是否明确了"改造现有"与"新增模块"的边界？
- [ ] 是否提供了迁移路径和回滚策略？
- [ ] 是否评估了对现有功能的影响范围？
- [ ] 技术决策是否有明确的理由和替代方案对比？

## 治理规则

### 章程优先级

- 本章程优先于所有其他实践规范
- 当其他文档与本章程冲突时，以本章程为准
- 若确需违反本章程某条原则，MUST 在设计文档中明确说明理由并获得人工确认

### 修订流程

- 章程修订需形成文档、获得批准并制定迁移计划
- 所有 PR/评审 MUST 验证设计方案是否符合本章程
- 复杂度增加 MUST 有合理依据（在 plan.md 的"复杂度跟踪"章节说明）

### 合规性检查

在进入 Implement 阶段前，MUST 通过以下检查：

- [ ] 设计方案符合"演进式设计"原则
- [ ] 技术选型与现有技术栈兼容
- [ ] 差距分析已完成且映射清晰
- [ ] 改动范围已明确且可控
- [ ] 风险已识别且有消解策略

**版本**：1.0.0 | **批准日期**：2025-01-21 | **最后修订日期**：2025-01-21
